<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal 3D Converter (+FBX)</title>
    
    <!-- Bootstrap for UI -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">

    <!-- Polyfills for Mobile/iOS Support -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.8.0/dist/es-module-shims.js"></script>

    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/", 
            "three-bvh-csg": "https://esm.sh/three-bvh-csg@0.0.16?deps=three@0.160.0",
            "fflate": "https://esm.sh/fflate@0.8.2"
        }
    }
    </script>

    <style>
        body { background-color: #121212; color: #e0e0e0; font-family: 'Segoe UI', sans-serif; height: 100vh; overflow: hidden; }
        
        /* Sidebar */
        .sidebar {
            width: 350px; background: #1e1e1e; border-right: 1px solid #333;
            display: flex; flex-direction: column; padding: 20px; z-index: 10;
            box-shadow: 2px 0 10px rgba(0,0,0,0.5);
        }
        
        /* Viewer Area */
        .viewer { flex: 1; position: relative; background: radial-gradient(circle at center, #2a2a2a 0%, #111 100%); }
        
        /* Controls */
        .form-control, .form-select { background: #2c2c2c; border: 1px solid #444; color: white; }
        .form-control:focus, .form-select:focus { background: #333; color: white; border-color: #0d6efd; box-shadow: none; }
        
        /* Status Overlay */
        #status-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 100; display: none;
            flex-direction: column; justify-content: center; align-items: center;
        }
        
        .drop-zone {
            border: 2px dashed #444; border-radius: 10px; padding: 30px; text-align: center;
            margin-bottom: 20px; transition: all 0.2s; cursor: pointer;
        }
        .drop-zone:hover { border-color: #0d6efd; background: #252525; }
        .drop-zone.dragover { border-color: #0d6efd; background: #2a2a3a; }
    </style>
</head>
<body class="d-flex">

    <!-- SIDEBAR CONTROLS -->
    <div class="sidebar">
        <h4 class="mb-4 text-primary"><i class="bi bi-arrow-repeat"></i> 3D Converter</h4>
        
        <!-- INPUT -->
        <div class="mb-4">
            <label class="form-label text-muted small fw-bold">1. IMPORT FILE</label>
            <div class="drop-zone" id="drop-zone" onclick="document.getElementById('file-input').click()">
                <i class="bi bi-cloud-upload fs-1 text-secondary"></i>
                <div class="mt-2 small text-muted">Click or Drop File<br>(STL, OBJ, FBX, GLB, USDZ)</div>
            </div>
            <!-- Added .fbx to accept attribute -->
            <input type="file" id="file-input" class="d-none" accept=".stl,.obj,.fbx,.glb,.gltf,.usdz">
            <div id="file-info" class="alert alert-dark border-secondary p-2 small d-none">
                <i class="bi bi-file-earmark-check"></i> <span id="file-name">Loaded</span>
            </div>
        </div>

        <!-- OUTPUT OPTIONS -->
        <div class="mb-auto">
            <label class="form-label text-muted small fw-bold">2. CONVERT OPTIONS</label>
            <div class="mb-3">
                <label class="small">Target Format</label>
                <select id="export-format" class="form-select">
                    <option value="stl">STL (3D Printing)</option>
                    <option value="obj">OBJ (Standard)</option>
                    <option value="glb">GLB (Android AR / Web)</option>
                    <option value="usdz">USDZ (Apple AR)</option>
                </select>
            </div>
            
            <div class="form-check form-switch mb-3">
                <input class="form-check-input" type="checkbox" id="ar-scale" checked>
                <label class="form-check-label small" for="ar-scale">
                    <strong>AR Scale Fix</strong> (mm &rarr; m)<br>
                    <span class="text-muted" style="font-size:0.75rem">Uncheck for 3D Printing (1:1)</span>
                </label>
            </div>
        </div>

        <!-- ACTION -->
        <button id="btn-convert" class="btn btn-primary w-100 py-2" disabled onclick="window.convert()">
            <i class="bi bi-download"></i> Convert & Download
        </button>
    </div>

    <!-- 3D VIEWER -->
    <div class="viewer" id="viewer-container"></div>

    <!-- LOADING OVERLAY -->
    <div id="status-overlay">
        <div class="spinner-border text-primary mb-3" style="width: 3rem; height: 3rem;"></div>
        <h5 class="text-white" id="status-text">Processing...</h5>
    </div>

    <!-- LOGIC -->
    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        
        // Loaders
        import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
        import { STLLoader } from "three/addons/loaders/STLLoader.js";
        import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
        import { USDZLoader } from "three/addons/loaders/USDZLoader.js";
        import { FBXLoader } from "three/addons/loaders/FBXLoader.js"; // Added FBX Loader
        
        // Exporters
        import { OBJExporter } from "three/addons/exporters/OBJExporter.js";
        import { STLExporter } from "three/addons/exporters/STLExporter.js";
        import { GLTFExporter } from "three/addons/exporters/GLTFExporter.js";
        import { USDZExporter } from "three/addons/exporters/USDZExporter.js";

        // GLOBALS
        let scene, camera, renderer, controls;
        let currentMesh = null;
        let originalFileName = "model";

        // --- 1. INITIALIZE VIEWER ---
        function init() {
            const container = document.getElementById("viewer-container");
            
            // Scene
            scene = new THREE.Scene();
            scene.background = null; 
            
            // Camera
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.01, 1000);
            camera.position.set(5, 5, 5);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            // Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);
            const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
            backLight.position.set(-5, -5, -5);
            scene.add(backLight);

            // Grid
            const grid = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
            scene.add(grid);

            // Resize
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- 2. FILE LOADING ---
        window.handleFile = async function(file) {
            showStatus("Loading Model...");
            originalFileName = file.name.split('.')[0];
            
            const ext = file.name.split('.').pop().toLowerCase();
            const reader = new FileReader();

            reader.onload = async (e) => {
                try {
                    let geometry;
                    const buffer = e.target.result;

                    // Remove old mesh
                    if(currentMesh) { scene.remove(currentMesh); currentMesh = null; }

                    // PARSE
                    if (ext === 'stl') {
                        geometry = new STLLoader().parse(buffer);
                    } else if (ext === 'obj') {
                        const text = new TextDecoder().decode(buffer);
                        const group = new OBJLoader().parse(text);
                        group.traverse(c => { if(c.isMesh && !geometry) geometry = c.geometry; });
                    } else if (ext === 'glb' || ext === 'gltf') {
                        await new Promise(resolve => {
                            new GLTFLoader().parse(buffer, '', (gltf) => {
                                gltf.scene.traverse(c => { if(c.isMesh && !geometry) geometry = c.geometry; });
                                resolve();
                            });
                        });
                    } else if (ext === 'usdz') {
                        const group = new USDZLoader().parse(buffer);
                        group.traverse(c => { if(c.isMesh && !geometry) geometry = c.geometry; });
                    } else if (ext === 'fbx') {
                        // NEW FBX HANDLING
                        const group = new FBXLoader().parse(buffer, '');
                        // Find the first valid mesh
                        group.traverse(c => { if(c.isMesh && !geometry) geometry = c.geometry; });
                    }

                    if (!geometry) throw new Error("No geometry found in file.");

                    // NORMALIZE & ADD TO SCENE
                    geometry.computeVertexNormals();
                    geometry.center();
                    
                    // Auto-Scale Visualization (Fit to View)
                    geometry.computeBoundingBox();
                    const size = geometry.boundingBox.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    let scale = 3 / maxDim; // Fit into roughly 3 units
                    
                    const material = new THREE.MeshStandardMaterial({ 
                        color: 0x0d6efd, roughness: 0.4, metalness: 0.1, side: THREE.DoubleSide 
                    });
                    
                    currentMesh = new THREE.Mesh(geometry, material);
                    
                    // Store raw geometry for export (don't bake visual scale)
                    currentMesh.userData.originalGeometry = geometry.clone();
                    
                    // Apply Visual Scale
                    currentMesh.scale.set(scale, scale, scale);
                    
                    scene.add(currentMesh);
                    
                    // UI Updates
                    document.getElementById('file-info').classList.remove('d-none');
                    document.getElementById('file-name').innerText = file.name;
                    document.getElementById('btn-convert').disabled = false;
                    hideStatus();

                } catch (err) {
                    console.error(err);
                    alert("Error loading file: " + err.message);
                    hideStatus();
                }
            };

            // Read as Text for OBJ, ArrayBuffer for everything else (including FBX)
            if (ext === 'obj') reader.readAsArrayBuffer(file); 
            else reader.readAsArrayBuffer(file);
        };

        // --- 3. CONVERSION & EXPORT ---
        window.convert = async function() {
            if (!currentMesh) return;
            const format = document.getElementById('export-format').value;
            const useARScale = document.getElementById('ar-scale').checked;
            
            showStatus("Converting to " + format.toUpperCase() + "...");

            // Create a clean mesh for export using the original (unscaled) geometry
            const exportGeo = currentMesh.userData.originalGeometry.clone();
            const exportMesh = new THREE.Mesh(exportGeo, new THREE.MeshStandardMaterial());
            
            // APPLY SCALING LOGIC
            if (useARScale && (format === 'usdz' || format === 'glb')) {
                exportMesh.scale.set(0.001, 0.001, 0.001);
            } else {
                exportMesh.scale.set(1, 1, 1);
            }
            exportMesh.updateMatrixWorld();

            try {
                let data;
                let mimeType = 'application/octet-stream';

                if (format === 'stl') {
                    data = new STLExporter().parse(exportMesh, { binary: true });
                } 
                else if (format === 'obj') {
                    data = new OBJExporter().parse(exportMesh);
                    mimeType = 'text/plain';
                } 
                else if (format === 'glb') {
                    data = await new Promise(resolve => {
                        new GLTFExporter().parse(exportMesh, resolve, { binary: true });
                    });
                } 
                else if (format === 'usdz') {
                    const exporter = new USDZExporter();
                    data = await exporter.parse(exportMesh);
                }

                // DOWNLOAD
                const blob = new Blob([data], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${originalFileName}_converted.${format}`;
                document.body.appendChild(link);
                link.click();
                
                setTimeout(() => {
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    hideStatus();
                }, 100);

            } catch (err) {
                alert("Conversion Failed: " + err.message);
                hideStatus();
            }
        };

        // --- UI HELPERS ---
        function showStatus(msg) {
            document.getElementById('status-text').innerText = msg;
            document.getElementById('status-overlay').style.display = 'flex';
        }
        function hideStatus() {
            document.getElementById('status-overlay').style.display = 'none';
        }

        // Initialize App
        init();

        // Bind File Input Events
        const input = document.getElementById('file-input');
        const dropZone = document.getElementById('drop-zone');

        input.addEventListener('change', (e) => {
            if(e.target.files.length) window.handleFile(e.target.files[0]);
        });

        // Drag & Drop
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            if(e.dataTransfer.files.length) window.handleFile(e.dataTransfer.files[0]);
        });

    </script>
</body>
</html>
