<!DOCTYPE html>
<html lang="en">
<head>    
    <script src="coi-serviceworker.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D Pro (Sizing Fixed)</title>
    
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css">

    <script async src="https://ga.jspm.io/npm:es-module-shims@1.8.0/dist/es-module-shims.js"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/", 
            "three-usdz-loader": "https://esm.sh/three-usdz-loader@1.0.9?external=three"
        }
    }
    </script>

    <style>
        :root { --app-height: 100svh; }
        body { background-color: #050505; color: #e0e0e0; font-family: system-ui, sans-serif; height: 100vh; height: 100svh; overflow: hidden; display: flex; flex-direction: row; margin: 0; }
        
        .sidebar { width: 360px; background: #151515; border-right: 1px solid #333; display: flex; flex-direction: column; padding: 20px; z-index: 20; overflow-y: auto; }
        .viewer { flex: 1; position: relative; background: radial-gradient(circle at center, #252525 0%, #000 100%); }
        
        /* Inputs */
        .form-control, .form-select, .input-group-text { background: #222; border: 1px solid #444; color: white; font-size: 0.85rem; }
        .form-control:focus { background: #333; color: white; border-color: #0d6efd; box-shadow: none; }
        .input-group-text { color: #888; border-color: #444; width: 45px; justify-content: center; }
        input[type=number]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

        .drop-zone { border: 2px dashed #444; border-radius: 8px; padding: 20px; text-align: center; margin-bottom: 20px; cursor: pointer; background: #1a1a1a; transition: 0.2s; }
        .drop-zone:hover { border-color: #0d6efd; background: #222; }

        #status-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000; display: none; flex-direction: column; justify-content: center; align-items: center; }

        @media (max-width: 900px) {
            body { flex-direction: column; }
            .viewer { height: 45%; width: 100%; order: 1; }
            .sidebar { width: 100%; height: 55%; order: 2; border-right: none; border-top: 2px solid #333; }
        }
    </style>
</head>
<body>

    <div class="viewer" id="viewer-container">
        <div style="position: absolute; top: 15px; left: 15px; pointer-events: none; opacity: 0.6; font-size: 12px;">
            <i class="bi bi-mouse"></i> Drag to Rotate &bull; Scroll to Zoom
        </div>
    </div>

    <div class="sidebar">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h6 class="text-white m-0 fw-bold"><i class="bi bi-box-seam text-primary"></i> 3D PRO EXPORTER</h6>
            <button class="btn btn-sm btn-outline-secondary" onclick="location.reload()" style="font-size: 0.75rem;">New</button>
        </div>
        
        <!-- DROP ZONE -->
        <div class="drop-zone" id="drop-zone" onclick="document.getElementById('file-input').click()">
            <i class="bi bi-cloud-upload fs-4 text-secondary"></i>
            <div class="mt-2 small text-muted">Click or Drag Files Here</div>
            <div style="font-size: 0.65rem; color: #555;">(GLB, USDZ, OBJ, STL, FBX)</div>
        </div>
        <input type="file" id="file-input" class="d-none" multiple accept="*">

        <!-- FILE INFO -->
        <div id="file-info" class="d-none mb-3 p-2 bg-dark rounded border border-secondary">
            <div class="d-flex justify-content-between small">
                <span class="text-white text-truncate" id="filename-display" style="max-width: 180px;">-</span>
                <span class="text-muted" id="texture-display">0 Maps</span>
            </div>
        </div>

        <!-- DIMENSIONS -->
        <div id="controls-section" class="d-none">
            
            <div class="mb-3">
                <label class="small text-muted fw-bold mb-2">TARGET DIMENSIONS (METERS)</label>
                
                <div class="input-group input-group-sm mb-2">
                    <span class="input-group-text">W</span>
                    <input type="number" id="dim-x" class="form-control" onchange="applyUserDimension('x')" step="0.01">
                    <span class="input-group-text">m</span>
                </div>
                <div class="input-group input-group-sm mb-2">
                    <span class="input-group-text">H</span>
                    <input type="number" id="dim-y" class="form-control" onchange="applyUserDimension('y')" step="0.01">
                    <span class="input-group-text">m</span>
                </div>
                <div class="input-group input-group-sm mb-2">
                    <span class="input-group-text">D</span>
                    <input type="number" id="dim-z" class="form-control" onchange="applyUserDimension('z')" step="0.01">
                    <span class="input-group-text">m</span>
                </div>
            </div>

            <div class="mb-4">
                <label class="small text-muted fw-bold mb-2">QUICK FIX: ORIGINAL UNITS</label>
                <div class="btn-group w-100" role="group">
                    <button class="btn btn-outline-secondary btn-sm" onclick="setBaseUnit('mm')">mm</button>
                    <button class="btn btn-outline-secondary btn-sm" onclick="setBaseUnit('cm')">cm</button>
                    <button class="btn btn-outline-secondary btn-sm" onclick="setBaseUnit('in')">inch</button>
                    <button class="btn btn-outline-secondary btn-sm" onclick="setBaseUnit('m')">meter</button>
                </div>
                <div class="text-muted mt-1" style="font-size: 0.7rem; line-height: 1.2;">
                    *Click what the model was built in to auto-correct scale for AR.
                </div>
            </div>

            <div class="mb-3">
                <label class="small text-muted fw-bold mb-1">ROTATION</label>
                <div class="d-flex gap-2">
                    <button class="btn btn-dark btn-sm flex-fill border-secondary" onclick="rotateModel('x')">X 90°</button>
                    <button class="btn btn-dark btn-sm flex-fill border-secondary" onclick="rotateModel('y')">Y 90°</button>
                    <button class="btn btn-dark btn-sm flex-fill border-secondary" onclick="rotateModel('z')">Z 90°</button>
                </div>
            </div>
        </div>

        <div class="mt-auto pt-3 border-top border-secondary">
            <div class="d-flex gap-2">
                <select id="export-format" class="form-select form-select-sm">
                    <option value="glb">GLB (Android/Web)</option>
                    <option value="usdz">USDZ (iPhone AR)</option>
                    <option value="obj">OBJ</option>
                    <option value="stl">STL</option>
                </select>
                <button id="btn-convert" class="btn btn-primary btn-sm px-4 flex-grow-1" disabled onclick="exportModel()">
                    Download
                </button>
            </div>
        </div>
    </div>

    <div id="status-overlay">
        <div class="spinner-border text-primary mb-3"></div>
        <div class="text-white fw-bold" id="status-text">Processing...</div>
    </div>

<script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
    import { MTLLoader } from "three/addons/loaders/MTLLoader.js";
    import { STLLoader } from "three/addons/loaders/STLLoader.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
    import { USDZLoader } from "three/addons/loaders/USDZLoader.js";
    import { USDZLoader as AdvancedUSDZLoader } from "three-usdz-loader";
    
    // Exporters
    import { GLTFExporter } from "three/addons/exporters/GLTFExporter.js";
    import { USDZExporter } from "three/addons/exporters/USDZExporter.js";
    import { OBJExporter } from "three/addons/exporters/OBJExporter.js";
    import { STLExporter } from "three/addons/exporters/STLExporter.js";

    let scene, camera, renderer, controls, gridHelper;
    let modelGroup = null; // The container for the loaded model
    let rawGeometryBox = null; // The bounding box of the unscaled geometry
    let currentFileName = "model";

    // Initialize Viewer
    function init() {
        const container = document.getElementById("viewer-container");
        
        scene = new THREE.Scene();
        // Slightly lighter background for better contrast
        scene.background = new THREE.Color(0x111111);

        camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.01, 2000);
        camera.position.set(2, 2, 5);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        container.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Lighting
        const ambient = new THREE.AmbientLight(0xffffff, 1.5);
        scene.add(ambient);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        const backLight = new THREE.DirectionalLight(0xffffff, 1.0);
        backLight.position.set(-5, 5, -5);
        scene.add(backLight);

        // Grid
        gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        scene.add(gridHelper);

        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });

        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    // --- FILE HANDLING ---
    
    const blobMap = {};

    window.handleFiles = async function(files) {
        if(modelGroup) { scene.remove(modelGroup); modelGroup = null; }
        
        document.getElementById('status-overlay').style.display = 'flex';
        document.getElementById('status-text').innerText = "Loading...";

        let mainFile = null;
        let mtlFile = null;
        let textureCount = 0;

        // Sort files
        for(let i=0; i<files.length; i++) {
            const f = files[i];
            const ext = f.name.split('.').pop().toLowerCase();
            const url = URL.createObjectURL(f);
            blobMap[f.name] = url; // Exact match
            blobMap[f.name.toLowerCase()] = url; // Lowercase match

            if(['obj','fbx','glb','gltf','stl','usdz'].includes(ext)) {
                mainFile = f;
                currentFileName = f.name.split('.')[0];
            } else if(ext === 'mtl') {
                mtlFile = f;
            } else if(['jpg','png','jpeg'].includes(ext)) {
                textureCount++;
            }
        }

        if(!mainFile) {
            alert("No 3D model found!");
            document.getElementById('status-overlay').style.display = 'none';
            return;
        }

        document.getElementById('file-info').classList.remove('d-none');
        document.getElementById('filename-display').innerText = mainFile.name;
        document.getElementById('texture-display').innerText = textureCount + " textures";

        try {
            await loadModel(mainFile, mtlFile);
        } catch(e) {
            console.error(e);
            alert("Error: " + e.message);
            document.getElementById('status-overlay').style.display = 'none';
        }
    };

    async function loadModel(file, mtlFile) {
        const manager = new THREE.LoadingManager();
        // Redirect texture requests to Blobs
        manager.setURLModifier((url) => {
            const name = url.split('/').pop();
            if(blobMap[name]) return blobMap[name];
            if(blobMap[name.toLowerCase()]) return blobMap[name.toLowerCase()];
            return url;
        });

        const ext = file.name.split('.').pop().toLowerCase();
        const buffer = await file.arrayBuffer();
        let object;

        if(ext === 'obj') {
            if(mtlFile) {
                const mtlStr = await mtlFile.text();
                const materials = new MTLLoader(manager).parse(mtlStr);
                materials.preload();
                object = new OBJLoader(manager).setMaterials(materials).parse(new TextDecoder().decode(buffer));
            } else {
                object = new OBJLoader(manager).parse(new TextDecoder().decode(buffer));
            }
        } else if(ext === 'glb' || ext === 'gltf') {
            const gltf = await new Promise((res, rej) => new GLTFLoader(manager).parse(buffer, '', res, rej));
            object = gltf.scene;
        } else if(ext === 'fbx') {
            object = new FBXLoader(manager).parse(buffer, '');
        } else if(ext === 'stl') {
            const geo = new STLLoader(manager).parse(buffer);
            object = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: 0xaaaaaa}));
        } else if(ext === 'usdz') {
            // Attempt standard loader first, then fallback to advanced
            try {
                object = new USDZLoader(manager).parse(buffer);
                if(object.children.length === 0) throw new Error("Empty USDZ");
            } catch(e) {
                console.log("Switching to advanced USDZ loader");
                const advancedLoader = new AdvancedUSDZLoader('./external');
                const group = new THREE.Group();
                
                // Hack fetch for advanced loader blobs
                const _fetch = window.fetch;
                window.fetch = (url, opts) => {
                    const name = url.split('/').pop();
                    if(blobMap[name]) return _fetch(blobMap[name], opts);
                    return _fetch(url, opts);
                }
                await advancedLoader.loadFile(file, group);
                window.fetch = _fetch;
                object = group;
            }
        }

        if(!object) throw new Error("Could not parse file");

        setupScene(object);
    }

    function setupScene(object) {
        modelGroup = new THREE.Group();
        
        // 1. Center the geometry inside the group
        const box = new THREE.Box3().setFromObject(object);
        
        // Handle Empty Models
        if(box.isEmpty()) {
            alert("Model appears empty or invisible.");
            document.getElementById('status-overlay').style.display = 'none';
            return;
        }

        const center = box.getCenter(new THREE.Vector3());
        object.position.sub(center); // Centers object at 0,0,0 inside group
        object.position.y += (box.max.y - box.min.y) / 2; // Sit on floor

        modelGroup.add(object);
        scene.add(modelGroup);

        // 2. Capture RAW size (Unscaled)
        // We need to know how big the geometry is naturally to calculate scale factors
        const size = new THREE.Vector3();
        box.getSize(size);
        rawGeometryBox = size; // e.g., {x: 100, y: 200, z: 50}

        // 3. Initial "Safe" View
        // If the model is crazy huge or tiny, let's just make sure the camera sees it.
        // We do NOT change the scale yet. We move the camera.
        fitCameraToObj(modelGroup);

        // 4. Update UI
        updateDimensionInputs();
        document.getElementById('controls-section').classList.remove('d-none');
        document.getElementById('btn-convert').disabled = false;
        document.getElementById('status-overlay').style.display = 'none';
    }

    // --- SCALING LOGIC ---

    // 1. Convert Unit Button Clicked
    window.setBaseUnit = function(unit) {
        if(!modelGroup || !rawGeometryBox) return;

        let multiplier = 1;
        // Logic: Convert FROM source unit TO Meters
        if(unit === 'mm') multiplier = 0.001;
        if(unit === 'cm') multiplier = 0.01;
        if(unit === 'in') multiplier = 0.0254;
        if(unit === 'm') multiplier = 1.0;

        // Apply scale
        modelGroup.scale.set(multiplier, multiplier, multiplier);
        
        // Recenter camera because object size changed drastically
        fitCameraToObj(modelGroup);
        updateDimensionInputs();
    }

    // 2. User typed specific number (e.g. 2.0 meters)
    window.applyUserDimension = function(axis) {
        if(!modelGroup || !rawGeometryBox) return;
        
        const inputId = `dim-${axis}`;
        const targetSize = parseFloat(document.getElementById(inputId).value);

        if(isNaN(targetSize) || targetSize <= 0) return;

        // rawGeometry * scale = targetSize
        // scale = targetSize / rawGeometry
        
        let newScale = 1;
        if(axis === 'x') newScale = targetSize / rawGeometryBox.x;
        if(axis === 'y') newScale = targetSize / rawGeometryBox.y;
        if(axis === 'z') newScale = targetSize / rawGeometryBox.z;

        modelGroup.scale.set(newScale, newScale, newScale);
        
        // Don't refit camera while typing, it's annoying. Just update numbers.
        updateDimensionInputs(); 
    }

    function updateDimensionInputs() {
        if(!modelGroup) return;
        
        // Calculate current Real-World size (Raw * Scale)
        const currentX = rawGeometryBox.x * modelGroup.scale.x;
        const currentY = rawGeometryBox.y * modelGroup.scale.y;
        const currentZ = rawGeometryBox.z * modelGroup.scale.z;

        // Update inputs (to 4 decimal places for precision)
        document.getElementById('dim-x').value = currentX.toFixed(4);
        document.getElementById('dim-y').value = currentY.toFixed(4);
        document.getElementById('dim-z').value = currentZ.toFixed(4);
    }

    // --- CAMERA & VIEWING ---

    function fitCameraToObj(group) {
        const box = new THREE.Box3().setFromObject(group);
        const size = new THREE.Vector3();
        box.getSize(size);
        const center = new THREE.Vector3();
        box.getCenter(center);

        const maxDim = Math.max(size.x, size.y, size.z);
        
        // Update Grid to match object scale (so it doesn't look like it's floating in void)
        scene.remove(gridHelper);
        const gridSize = Math.max(10, maxDim * 5);
        const gridDivs = 10;
        gridHelper = new THREE.GridHelper(gridSize, gridDivs, 0x444444, 0x222222);
        scene.add(gridHelper);

        // Adjust Clipping Planes (Crucial for tiny/huge objects)
        camera.near = maxDim / 1000;
        camera.far = maxDim * 100;
        camera.updateProjectionMatrix();

        // Move Camera
        const fov = camera.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / 2 * Math.tan(fov * 2));
        cameraZ *= 2.0; // Zoom out multiplier

        camera.position.set(center.x + cameraZ, center.y + (cameraZ * 0.5), center.z + cameraZ);
        camera.lookAt(center);
        
        controls.target.copy(center);
        controls.update();
    }

    window.rotateModel = function(axis) {
        if(!modelGroup) return;
        modelGroup.rotation[axis] += Math.PI / 2;
        fitCameraToObj(modelGroup); // Re-center in case rotation swings it out of view
    }

    // --- EXPORT ---

    window.exportModel = async function() {
        if(!modelGroup) return;
        
        const format = document.getElementById('export-format').value;
        const btn = document.getElementById('btn-convert');
        btn.disabled = true;
        btn.innerText = "Processing...";

        // Clone so we can bake the matrix without ruining the view
        const exportScene = modelGroup.clone();
        
        // BAKE TRANSFORMATIONS: This makes the Scale/Rotation permanent in the geometry
        exportScene.updateMatrixWorld(true);
        exportScene.traverse((child) => {
            if (child.isMesh) {
                // Apply the group's scale/rotation to the mesh geometry directly
                child.geometry.applyMatrix4(child.parent.matrixWorld);
                child.updateMatrix(); // Reset matrix to identity
            }
        });
        // Reset the group wrapper since we baked it into children
        exportScene.scale.set(1,1,1);
        exportScene.rotation.set(0,0,0);
        exportScene.position.set(0,0,0);

        try {
            let data;
            const filename = `${currentFileName}_AR.${format}`;

            if(format === 'glb') {
                const exp = new GLTFExporter();
                data = await new Promise(r => exp.parse(exportScene, r, {binary:true}));
                saveArrayBuffer(data, filename);
            }
            else if(format === 'usdz') {
                const exp = new USDZExporter();
                data = await exp.parse(exportScene);
                saveArrayBuffer(data, filename);
            }
            else if(format === 'obj') {
                const txt = new OBJExporter().parse(exportScene);
                saveString(txt, filename);
            }
            else if(format === 'stl') {
                const view = new STLExporter().parse(exportScene, {binary:true});
                saveArrayBuffer(view.buffer, filename);
            }

        } catch(e) {
            console.error(e);
            alert("Export failed: " + e.message);
        }

        btn.disabled = false;
        btn.innerText = "Download";
    };

    function saveArrayBuffer(buffer, filename) {
        const blob = new Blob([buffer], {type: 'application/octet-stream'});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
    }
    
    function saveString(text, filename) {
        const blob = new Blob([text], {type: 'text/plain'});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
    }

    // Init listeners
    init();
    
    const dropZone = document.getElementById('drop-zone');
    dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.style.background = '#333'; });
    dropZone.addEventListener('dragleave', e => { e.preventDefault(); dropZone.style.background = '#1a1a1a'; });
    dropZone.addEventListener('drop', e => { 
        e.preventDefault(); 
        dropZone.style.background = '#1a1a1a';
        if(e.dataTransfer.files.length) window.handleFiles(e.dataTransfer.files);
    });
    document.getElementById('file-input').addEventListener('change', e => {
        if(e.target.files.length) window.handleFiles(e.target.files);
    });

</script>
</body>
</html>
